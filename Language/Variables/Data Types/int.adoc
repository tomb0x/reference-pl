---
title: int
categories: [ "Zmienne" ]
subCategories: [ "Typy danych" ]
---

= int


// POCZĄTEK SEKCJI OPISOWEJ
[#overview]
--

[float]
=== Opis
Liczby całkowite są podstawowym typem danych do przechowywania liczb.

Na Arduino Uno (i innych płytach opartych na ATmega) typ int przechowuje wartość 16-bitową (2-bajtową). Daje to zakres od -32.768 do 32.767 (minimalna wartość -2^15 i maksymalna wartość (2^15)-1).
Na płytach opartych na Arduino Due i SAMD (takich jak MKR1000 i Zero), typ int przechowuje wartość 32-bitową (4-bajtową). Daje to zakres -2.147.483.648 do 2.147.483.647 (minimalna wartość -2^31 i maksymalna wartość (2^31)-1).

Typ int przechowuje liczby ujemne za pomocą techniki znanej jako (https://pl.wikipedia.org/wiki/Kod_uzupe%C5%82nie%C5%84_do_dw%C3%B3ch[Kod uzupełnień do dwóch]). Ustawiony najbardziej znaczący bit, czasami nazywany bitem "znaku", oznacza liczbę ujemną. Reszta bitów jest odwrócona i dodane jest 1.

Arduino dba o to, abyś radził sobie z liczbami ujemnymi, wykonując operacje arytmetyczne w oczekiwany sposób. There can be an unexpected complication in dealing with the link:../../../structure/bitwise-operators/bitshiftright/[bitshift right operator] (>>) however.
[%hardbreaks]


[float]
=== Składnia
`int var = val;`


[float]
=== Parametry
`var`: variable name. +
`val`: the value you assign to that variable.

--
// KONIEC SEKCJI OPISOWEJ




// POCZĄTEK SEKCJI JAK UŻYWAĆ
[#howtouse]
--

[float]
=== Przykładowy kod
This code creates an integer called 'countUp', which is initially set as the number 0 (zero). The variable goes up by 1 (one) each loop, being displayed on the serial monitor.

[source,arduino]
----
int countUp = 0;            //creates a variable integer called 'countUp'

void setup() {
  Serial.begin(9600);       // use the serial port to print the number
}

void loop() {
  countUp++;                //Adds 1 to the countUp int on every loop
  Serial.println(countUp);  // prints out the current state of countUp
  delay(1000);
}
----
[%hardbreaks]

[float]
=== Uwagi i ostrzeżenia
When signed variables are made to exceed their maximum or minimum capacity they _overflow_. The result of an overflow is unpredictable so this should be avoided. A typical symptom of an overflow is the variable "rolling over" from its maximum capacity to its minimum or vice versa, but this is not always the case. If you want this behavior, use link:../unsignedint/[unsigned int].


--
// KONIEC SEKCJI JAK UŻYWAĆ


// POCZĄTEK SEKCJI ZOBACZ TAKŻE
[#see_also]
--

[float]
=== Zobacz także

[role="language"]
* #LANGUAGE# link:../../constants/integerconstants[Integer Constants]

--
// KONIEC SEKCJI ZOBACZ TAKŻE
